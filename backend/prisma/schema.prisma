// prisma/schema.prisma
// Data model for Hinge-like app: profiles, photos, prompts,
// targeted likes (photo/prompt), matches, conversations, messages.

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ----- Enums -----
enum LikeStatus {
  PENDING
  ACCEPTED
  SKIPPED
}

enum MessageKind {
  TEXT
  LIKE
}

// ----- Core Models -----
model User {
  id            String   @id @default(cuid())
  email         String   @unique
  passwordHash  String
  name          String?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Relations
  profile       Profile?
  // Likes
  sentLikes     Like[]   @relation("sentlikes")
  receivedLikes Like[]   @relation("receivedlikes")
  // Messages
  messages      Message[]
  // Sessions (optional)
  sessions      Session[]
  // Matches (back-relations for Match.userA and Match.userB)
  matchesAsUserA Match[] @relation("userA")
  matchesAsUserB Match[] @relation("userB")

  @@index([email])
}

model Profile {
  id         String   @id @default(cuid())
  userId     String   @unique
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Basics
  dob        DateTime?
  location   String?
  gender     String?
  jobTitle   String?
  company    String?
  school     String?

  photos     Photo[]
  prompts    Prompt[]

  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
}

model Photo {
  id         String   @id @default(cuid())
  profileId  String
  profile    Profile  @relation(fields: [profileId], references: [id], onDelete: Cascade)

  url        String
  position   Int      @default(0)
  createdAt  DateTime @default(now())

  @@index([profileId, position])
}

model Prompt {
  id         String   @id @default(cuid())
  profileId  String
  profile    Profile  @relation(fields: [profileId], references: [id], onDelete: Cascade)

  question   String
  answer     String
  createdAt  DateTime @default(now())

  @@index([profileId])
}

// A Like is created by one user (fromUser) for another (toUser).
// It can target a photo or a prompt via `context` JSON.
model Like {
  id          String      @id @default(cuid())
  fromUserId  String
  fromUser    User        @relation("sentlikes", fields: [fromUserId], references: [id], onDelete: Cascade)

  toUserId    String
  toUser      User        @relation("receivedlikes", fields: [toUserId], references: [id], onDelete: Cascade)

  comment     String?
  context     Json?       // e.g., { "photoIndex": 1 } OR { "promptId": "p1_a" }
  status      LikeStatus  @default(PENDING)

  createdAt   DateTime    @default(now())

  // Backref to Match (when accepted)
  acceptedBy  Match?

  @@index([toUserId, status, createdAt])
  @@index([fromUserId, createdAt])
}

// Once a like is accepted, we create a Match (A,B) and a Conversation.
model Match {
  id         String   @id @default(cuid())

  userAId    String
  userA      User     @relation("userA", fields: [userAId], references: [id], onDelete: Cascade)

  userBId    String
  userB      User     @relation("userB", fields: [userBId], references: [id], onDelete: Cascade)

  likeId     String   @unique
  like       Like     @relation(fields: [likeId], references: [id], onDelete: Cascade)

  createdAt  DateTime @default(now())

  // 1-1 with Conversation
  conversation Conversation?

  @@index([userAId])
  @@index([userBId])
  // (Optional) To prevent duplicate matches regardless of order you'd need a DB-level check.
  // As a simpler approach, you can enforce ordering of A/B in code.
}

model Conversation {
  id         String   @id @default(cuid())

  matchId    String   @unique
  match      Match    @relation(fields: [matchId], references: [id], onDelete: Cascade)

  createdAt  DateTime @default(now())
  messages   Message[]
}

model Message {
  id              String       @id @default(cuid())
  conversationId  String
  conversation    Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  authorId        String
  author          User         @relation(fields: [authorId], references: [id], onDelete: Cascade)

  kind            MessageKind  @default(TEXT)
  text            String?

  createdAt       DateTime     @default(now())

  @@index([conversationId, createdAt])
  @@index([authorId, createdAt])
}

// Optional: server-managed sessions (if you store JTI or refresh tokens)
model Session {
  id         String   @id @default(cuid())
  userId     String
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  jti        String   @unique
  createdAt  DateTime @default(now())
  expiresAt  DateTime

  @@index([userId])
}